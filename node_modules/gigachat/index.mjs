import axios from 'axios';
import { AuthenticationError } from "./exceptions.mjs";
import { get_balance, get_image, get_model, get_models, get_file, get_files, post_ai_check, post_auth, post_chat, post_embeddings, post_files, post_files_delete, post_token, post_tokens_count, stream_chat, stream_chat_readable, } from "./api/index.mjs";
import { getDefaultSettings } from "./settings.mjs";
import { isRunningInBrowser } from "./api/utils.mjs";
const GIGACHAT_MODEL = 'GigaChat';
export function detectImage(message) {
    const regex = /<img\ssrc="(?<uuid>.+?)"\sfuse="true"\/>(?<postfix>.*)?/ms;
    const match = regex.exec(message);
    if (!match || !match.groups)
        return null;
    return {
        uuid: match.groups['uuid'],
        postfix: match.groups['postfix'],
    };
}
export function detectVideo(message) {
    const regex = /<video\scover="(?<cover_uuid>.+?)"\ssrc="(?<uuid>.+?)"\sfuse="true"\/>(?<postfix>.+)?/ms;
    const match = regex.exec(message);
    if (!match || !match.groups)
        return null;
    return {
        uuid: match.groups['uuid'],
        cover_uuid: match.groups['cover_uuid'],
        postfix: match.groups['postfix'],
    };
}
export class GigaChat {
    constructor(config) {
        this._settings = { ...getDefaultSettings(), ...config };
        if (!this._settings.dangerouslyAllowBrowser && isRunningInBrowser()) {
            throw new Error('Скорее всего вы пытаетесь запустить библиотеку GigaChat в браузере. Такое использование выключено по умолчанию, так как при таком использовании вы рискуете разоблачить ваш токен GigaChat третьим лицам! Чтобы включить использование библиотеки проставьте параметр dangerouslyAllowBrowser. ');
        }
        if (this._settings.accessToken) {
            this._accessToken = {
                access_token: this._settings.accessToken,
                expires_at: 0,
            };
        }
        this._client = axios.create(this._getAxiosConfig());
        this._authClient = axios.create(this._getAuthAxiosConfig());
        if (this._settings.accessToken) {
            this._accessToken = {
                access_token: this._settings.accessToken,
                expires_at: 0,
            };
        }
    }
    get token() {
        return this._accessToken?.access_token;
    }
    get useAuth() {
        return Boolean(this._settings.credentials || (this._settings.user && this._settings.password));
    }
    checkValidityToken() {
        /** Проверить время завершения действия токена */
        return !!this._accessToken;
    }
    resetToken() {
        /** Сбросить токен */
        this._accessToken = undefined;
    }
    parseChat(payload) {
        let chat;
        if (typeof payload === 'string') {
            chat = {
                messages: [{ role: 'user', content: payload }],
            };
        }
        else {
            chat = payload;
        }
        chat.model = chat.model ?? this._settings.model ?? GIGACHAT_MODEL;
        chat.profanity_check = chat.profanity_check ?? this._settings.profanityCheck;
        chat.flags = chat.flags ?? this._settings.flags;
        return chat;
    }
    _getAxiosConfig() {
        return {
            baseURL: this._settings.baseUrl,
            timeout: this._settings.timeout * 1000,
            httpsAgent: this._settings.httpsAgent,
            validateStatus: () => true,
        };
    }
    _getAuthAxiosConfig() {
        return {
            httpsAgent: this._settings.httpsAgent,
            timeout: this._settings.timeout * 1000,
            validateStatus: () => true,
        };
    }
    async updateToken() {
        // if (authorization_cvar.get() !== undefined) {
        //     return;
        // }
        if (this._settings.credentials) {
            this._accessToken = await post_auth(this._authClient, {
                url: this._settings.authUrl,
                credentials: this._settings.credentials,
                scope: this._settings.scope,
            });
            console.info('OAUTH UPDATE TOKEN');
        }
        else if (this._settings.user && this._settings.password) {
            const token = await post_token(this._client, {
                user: this._settings.user,
                password: this._settings.password,
            });
            this._accessToken = this._buildAccessToken(token);
            console.info('UPDATE TOKEN');
        }
    }
    async _decorator(call) {
        if (this.useAuth) {
            if (this.checkValidityToken()) {
                try {
                    return await call();
                }
                catch (error) {
                    if (error instanceof AuthenticationError) {
                        console.warn('AUTHENTICATION ERROR');
                        this.resetToken();
                    }
                    else {
                        throw error;
                    }
                }
            }
            await this.updateToken();
        }
        return await call();
    }
    async tokensCount(input, model) {
        if (!model) {
            model = this._settings.model || GIGACHAT_MODEL;
        }
        return this._decorator(() => post_tokens_count(this._client, {
            input,
            model: model || this._settings.model || GIGACHAT_MODEL,
            accessToken: this.token,
        }));
    }
    async aiCheck(input, model) {
        return this._decorator(() => post_ai_check(this._client, {
            input,
            model,
            accessToken: this.token,
        }));
    }
    async balance() {
        return this._decorator(() => get_balance(this._client, { accessToken: this.token }));
    }
    async embeddings(texts, model = 'Embeddings') {
        return this._decorator(() => post_embeddings(this._client, {
            accessToken: this.token,
            input: texts,
            model,
        }));
    }
    async getModels() {
        return this._decorator(() => get_models(this._client, { accessToken: this.token }));
    }
    async getModel(model) {
        return this._decorator(() => get_model(this._client, {
            model,
            accessToken: this.token,
        }));
    }
    async getImage(fileId) {
        return this._decorator(() => get_image(this._client, {
            fileId,
            accessToken: this.token,
        }));
    }
    async uploadFile(file, purpose = 'general') {
        return this._decorator(() => post_files(this._client, { file, purpose, accessToken: this.token }));
    }
    async getFile(file) {
        return this._decorator(() => get_file(this._client, { file, accessToken: this.token }));
    }
    async getFiles() {
        return this._decorator(() => get_files(this._client, { accessToken: this.token }));
    }
    async deleteFile(file) {
        return this._decorator(() => post_files_delete(this._client, { file, accessToken: this.token }));
    }
    async chat(payload) {
        const chat = this.parseChat(payload);
        return this._decorator(() => post_chat(this._client, {
            chat,
            accessToken: this.token,
        }));
    }
    async stream_readable(payload, abortSignal) {
        const chat = this.parseChat(payload);
        return this._decorator(() => stream_chat_readable(this._client, {
            chat,
            accessToken: this.token,
        }, this._settings.dangerouslyAllowBrowser, abortSignal));
    }
    async *stream(payload, abortSignal) {
        const chat = this.parseChat(payload);
        if (this.useAuth) {
            if (this.checkValidityToken()) {
                try {
                    const stream = await stream_chat(this._client, { chat, accessToken: this.token }, this._settings.dangerouslyAllowBrowser, abortSignal);
                    for await (const chunk of stream) {
                        yield chunk;
                    }
                    return;
                }
                catch (error) {
                    if (error instanceof AuthenticationError) {
                        console.warn('AUTHENTICATION ERROR');
                        this.resetToken();
                    }
                    else {
                        throw error;
                    }
                }
            }
            await this.updateToken();
        }
        const stream = await stream_chat(this._client, { chat, accessToken: this.token }, this._settings.dangerouslyAllowBrowser, abortSignal);
        for await (const chunk of stream) {
            yield chunk;
        }
    }
    _buildAccessToken(token) {
        return {
            access_token: token.tok,
            expires_at: token.exp,
        };
    }
}
export default GigaChat;
//# sourceMappingURL=index.mjs.map