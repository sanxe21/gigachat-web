"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GigaChat = void 0;
exports.detectImage = detectImage;
exports.detectVideo = detectVideo;
const axios_1 = __importDefault(require("axios"));
const exceptions_1 = require("./exceptions.js");
const api_1 = require("./api/index.js");
const settings_1 = require("./settings.js");
const utils_1 = require("./api/utils.js");
const GIGACHAT_MODEL = 'GigaChat';
function detectImage(message) {
    const regex = /<img\ssrc="(?<uuid>.+?)"\sfuse="true"\/>(?<postfix>.*)?/ms;
    const match = regex.exec(message);
    if (!match || !match.groups)
        return null;
    return {
        uuid: match.groups['uuid'],
        postfix: match.groups['postfix'],
    };
}
function detectVideo(message) {
    const regex = /<video\scover="(?<cover_uuid>.+?)"\ssrc="(?<uuid>.+?)"\sfuse="true"\/>(?<postfix>.+)?/ms;
    const match = regex.exec(message);
    if (!match || !match.groups)
        return null;
    return {
        uuid: match.groups['uuid'],
        cover_uuid: match.groups['cover_uuid'],
        postfix: match.groups['postfix'],
    };
}
class GigaChat {
    constructor(config) {
        this._settings = { ...(0, settings_1.getDefaultSettings)(), ...config };
        if (!this._settings.dangerouslyAllowBrowser && (0, utils_1.isRunningInBrowser)()) {
            throw new Error('Скорее всего вы пытаетесь запустить библиотеку GigaChat в браузере. Такое использование выключено по умолчанию, так как при таком использовании вы рискуете разоблачить ваш токен GigaChat третьим лицам! Чтобы включить использование библиотеки проставьте параметр dangerouslyAllowBrowser. ');
        }
        if (this._settings.accessToken) {
            this._accessToken = {
                access_token: this._settings.accessToken,
                expires_at: 0,
            };
        }
        this._client = axios_1.default.create(this._getAxiosConfig());
        this._authClient = axios_1.default.create(this._getAuthAxiosConfig());
        if (this._settings.accessToken) {
            this._accessToken = {
                access_token: this._settings.accessToken,
                expires_at: 0,
            };
        }
    }
    get token() {
        return this._accessToken?.access_token;
    }
    get useAuth() {
        return Boolean(this._settings.credentials || (this._settings.user && this._settings.password));
    }
    checkValidityToken() {
        /** Проверить время завершения действия токена */
        return !!this._accessToken;
    }
    resetToken() {
        /** Сбросить токен */
        this._accessToken = undefined;
    }
    parseChat(payload) {
        let chat;
        if (typeof payload === 'string') {
            chat = {
                messages: [{ role: 'user', content: payload }],
            };
        }
        else {
            chat = payload;
        }
        chat.model = chat.model ?? this._settings.model ?? GIGACHAT_MODEL;
        chat.profanity_check = chat.profanity_check ?? this._settings.profanityCheck;
        chat.flags = chat.flags ?? this._settings.flags;
        return chat;
    }
    _getAxiosConfig() {
        return {
            baseURL: this._settings.baseUrl,
            timeout: this._settings.timeout * 1000,
            httpsAgent: this._settings.httpsAgent,
            validateStatus: () => true,
        };
    }
    _getAuthAxiosConfig() {
        return {
            httpsAgent: this._settings.httpsAgent,
            timeout: this._settings.timeout * 1000,
            validateStatus: () => true,
        };
    }
    async updateToken() {
        // if (authorization_cvar.get() !== undefined) {
        //     return;
        // }
        if (this._settings.credentials) {
            this._accessToken = await (0, api_1.post_auth)(this._authClient, {
                url: this._settings.authUrl,
                credentials: this._settings.credentials,
                scope: this._settings.scope,
            });
            console.info('OAUTH UPDATE TOKEN');
        }
        else if (this._settings.user && this._settings.password) {
            const token = await (0, api_1.post_token)(this._client, {
                user: this._settings.user,
                password: this._settings.password,
            });
            this._accessToken = this._buildAccessToken(token);
            console.info('UPDATE TOKEN');
        }
    }
    async _decorator(call) {
        if (this.useAuth) {
            if (this.checkValidityToken()) {
                try {
                    return await call();
                }
                catch (error) {
                    if (error instanceof exceptions_1.AuthenticationError) {
                        console.warn('AUTHENTICATION ERROR');
                        this.resetToken();
                    }
                    else {
                        throw error;
                    }
                }
            }
            await this.updateToken();
        }
        return await call();
    }
    async tokensCount(input, model) {
        if (!model) {
            model = this._settings.model || GIGACHAT_MODEL;
        }
        return this._decorator(() => (0, api_1.post_tokens_count)(this._client, {
            input,
            model: model || this._settings.model || GIGACHAT_MODEL,
            accessToken: this.token,
        }));
    }
    async aiCheck(input, model) {
        return this._decorator(() => (0, api_1.post_ai_check)(this._client, {
            input,
            model,
            accessToken: this.token,
        }));
    }
    async balance() {
        return this._decorator(() => (0, api_1.get_balance)(this._client, { accessToken: this.token }));
    }
    async embeddings(texts, model = 'Embeddings') {
        return this._decorator(() => (0, api_1.post_embeddings)(this._client, {
            accessToken: this.token,
            input: texts,
            model,
        }));
    }
    async getModels() {
        return this._decorator(() => (0, api_1.get_models)(this._client, { accessToken: this.token }));
    }
    async getModel(model) {
        return this._decorator(() => (0, api_1.get_model)(this._client, {
            model,
            accessToken: this.token,
        }));
    }
    async getImage(fileId) {
        return this._decorator(() => (0, api_1.get_image)(this._client, {
            fileId,
            accessToken: this.token,
        }));
    }
    async uploadFile(file, purpose = 'general') {
        return this._decorator(() => (0, api_1.post_files)(this._client, { file, purpose, accessToken: this.token }));
    }
    async getFile(file) {
        return this._decorator(() => (0, api_1.get_file)(this._client, { file, accessToken: this.token }));
    }
    async getFiles() {
        return this._decorator(() => (0, api_1.get_files)(this._client, { accessToken: this.token }));
    }
    async deleteFile(file) {
        return this._decorator(() => (0, api_1.post_files_delete)(this._client, { file, accessToken: this.token }));
    }
    async chat(payload) {
        const chat = this.parseChat(payload);
        return this._decorator(() => (0, api_1.post_chat)(this._client, {
            chat,
            accessToken: this.token,
        }));
    }
    async stream_readable(payload, abortSignal) {
        const chat = this.parseChat(payload);
        return this._decorator(() => (0, api_1.stream_chat_readable)(this._client, {
            chat,
            accessToken: this.token,
        }, this._settings.dangerouslyAllowBrowser, abortSignal));
    }
    async *stream(payload, abortSignal) {
        const chat = this.parseChat(payload);
        if (this.useAuth) {
            if (this.checkValidityToken()) {
                try {
                    const stream = await (0, api_1.stream_chat)(this._client, { chat, accessToken: this.token }, this._settings.dangerouslyAllowBrowser, abortSignal);
                    for await (const chunk of stream) {
                        yield chunk;
                    }
                    return;
                }
                catch (error) {
                    if (error instanceof exceptions_1.AuthenticationError) {
                        console.warn('AUTHENTICATION ERROR');
                        this.resetToken();
                    }
                    else {
                        throw error;
                    }
                }
            }
            await this.updateToken();
        }
        const stream = await (0, api_1.stream_chat)(this._client, { chat, accessToken: this.token }, this._settings.dangerouslyAllowBrowser, abortSignal);
        for await (const chunk of stream) {
            yield chunk;
        }
    }
    _buildAccessToken(token) {
        return {
            access_token: token.tok,
            expires_at: token.exp,
        };
    }
}
exports.GigaChat = GigaChat;
exports.default = GigaChat;
//# sourceMappingURL=index.js.map