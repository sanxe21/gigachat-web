"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stream_chat = stream_chat;
exports.stream_chat_readable = stream_chat_readable;
const axios_1 = __importDefault(require("axios"));
const utils_1 = require("./utils.js");
const exceptions_1 = require("../exceptions.js");
const events_1 = require("events");
const EVENT_STREAM = 'text/event-stream';
function getRequestConfig({ chat, accessToken }, isBrowser = false, abortSignal) {
    const headers = (0, utils_1.buildHeaders)(accessToken);
    if (!isBrowser) {
        headers['Accept'] = EVENT_STREAM;
        headers['Cache-Control'] = 'no-store';
    }
    const config = {
        method: 'POST',
        url: '/chat/completions',
        responseType: 'stream',
        data: { ...chat, ...{ stream: true } },
        headers: headers,
        signal: abortSignal,
    };
    if (isBrowser) {
        config.adapter = 'fetch';
    }
    return config;
}
function checkContentType(response) {
    const contentType = response.headers['content-type']?.split(';')[0];
    if (contentType !== EVENT_STREAM) {
        throw new Error(`Expected response Content-Type to be '${EVENT_STREAM}', got '${contentType}'`);
    }
}
function checkResponse(response) {
    if (response.status === 200) {
        checkContentType(response);
    }
    else if (response.status === 401) {
        console.error(response.data);
        throw new exceptions_1.AuthenticationError(response);
    }
    else {
        console.error(response.data);
        throw new exceptions_1.ResponseError(response);
    }
}
function splitLines(data) {
    return data.split(/\r?\n/).filter((line) => line.trim() !== '');
}
async function stream_chat(client, args, isBrowser = false, abortSignal) {
    let done = false;
    const pushQueue = [];
    const readQueue = [];
    const readable = await stream_chat_readable(client, args, isBrowser, abortSignal);
    function t() {
        return {
            next() {
                if (!pushQueue.length) {
                    if (done) {
                        return { value: undefined, done: true };
                    }
                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));
                }
                const chunk = pushQueue.shift();
                return { value: chunk, done: false };
            },
        };
    }
    const iterable = {
        [Symbol.asyncIterator]: t,
    };
    readable.on('chunk', (chunk) => {
        const reader = readQueue.shift();
        if (reader) {
            reader.resolve(chunk);
        }
        else {
            pushQueue.push(chunk);
        }
    });
    readable.on('end', (chunk) => {
        done = true;
        for (const reader of readQueue) {
            reader.resolve(undefined);
        }
        readQueue.length = 0;
    });
    return iterable;
}
async function stream_chat_readable(client, args, isBrowser = false, abortSignal) {
    const config = getRequestConfig(args, isBrowser, abortSignal);
    const emitter = new events_1.EventEmitter();
    const response = await client.request(config);
    checkResponse(response);
    if (isBrowser) {
        const reader = response.data.getReader();
        reader.read().then(function pump({ done, value }) {
            if (done) {
                emitter.emit('end');
                return;
            }
            else {
                const chunk = new TextDecoder().decode(value);
                const lines = splitLines(chunk.toString());
                lines.forEach((line) => {
                    const chatChunk = (0, utils_1.parseChunk)(line);
                    if (chatChunk) {
                        emitter.emit('chunk', (0, utils_1.buildXHeaders)(response, chatChunk)); // Отправка события с новым чанком
                    }
                });
            }
            return reader.read().then(pump);
        });
    }
    else {
        response.data.on('data', (chunk) => {
            const lines = splitLines(chunk.toString());
            lines.forEach((line) => {
                const chatChunk = (0, utils_1.parseChunk)(line);
                if (chatChunk) {
                    emitter.emit('chunk', (0, utils_1.buildXHeaders)(response, chatChunk)); // Отправка события с новым чанком
                }
            });
        });
        response.data.on('end', () => {
            emitter.emit('end'); // Отправка события завершения
        });
        response.data.on('error', (error) => {
            if (!axios_1.default.isCancel(error)) {
                emitter.emit('error', error); // Отправка события ошибки
            }
        });
    }
    return emitter;
}
//# sourceMappingURL=stream_chat.js.map